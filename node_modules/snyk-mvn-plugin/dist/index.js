"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const javaCallGraphBuilder = require("@snyk/java-call-graph-builder");
const os = require("os");
const fs = require("fs");
const path = require("path");
const debugModule = require("debug");
const parse_mvn_1 = require("./parse-mvn");
const subProcess = require("./sub-process");
const jar_1 = require("./jar");
const call_graph_error_1 = require("./errors/call-graph-error");
const error_format_1 = require("./error-format");
// To enable debugging output, use `snyk -d`
let logger = null;
function debug(s) {
    if (logger === null) {
        // Lazy init: Snyk CLI needs to process the CLI argument "-d" first.
        // TODO(BST-648): more robust handling of the debug settings
        if (process.env.DEBUG) {
            debugModule.enable(process.env.DEBUG);
        }
        logger = debugModule('snyk-mvn-plugin');
    }
    logger(s);
}
function getCommand(root, targetFile) {
    if (!targetFile) {
        return 'mvn';
    }
    const isWinLocal = /^win/.test(os.platform()); // local check, can be stubbed in tests
    const wrapperScript = isWinLocal ? 'mvnw.cmd' : './mvnw';
    // try to find a sibling wrapper script first
    let pathToWrapper = path.resolve(root, path.dirname(targetFile), wrapperScript);
    if (fs.existsSync(pathToWrapper)) {
        return wrapperScript;
    }
    // now try to find a wrapper in the root
    pathToWrapper = path.resolve(root, wrapperScript);
    if (fs.existsSync(pathToWrapper)) {
        return wrapperScript;
    }
    return 'mvn';
}
exports.getCommand = getCommand;
// When we have `mvn`, we can run the subProcess from anywhere.
// However due to https://github.com/takari/maven-wrapper/issues/133, `mvnw` can only be run
// within the directory where `mvnw` exists
function calculateTargetFilePath(mavenCommand, root, targetPath) {
    return mavenCommand === 'mvn' ? root : path.dirname(targetPath);
}
function inspect(root, targetFile, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const targetPath = targetFile
            ? path.resolve(root, targetFile)
            : path.resolve(root);
        if (!fs.existsSync(targetPath)) {
            throw new Error('Could not find file or directory ' + targetPath);
        }
        if (!options) {
            options = { dev: false, scanAllUnmanaged: false };
        }
        if (jar_1.isJar(targetPath)) {
            debug(`Creating pom from jar ${targetFile}`);
            targetFile = yield jar_1.createPomForJar(root, targetFile);
        }
        if (options.scanAllUnmanaged) {
            if (jar_1.containsJar(root)) {
                debug(`Creating pom from jars in for ${root}`);
                targetFile = yield jar_1.createPomForJars(root);
            }
            else {
                throw Error(`Could not find any supported files in '${root}'.`);
            }
        }
        const mvnArgs = buildArgs(targetFile, options.args);
        const mavenCommand = getCommand(root, targetFile);
        const targetFilePath = calculateTargetFilePath(mavenCommand, root, targetPath);
        try {
            const result = yield subProcess.execute(mavenCommand, mvnArgs, {
                cwd: targetFilePath,
            });
            const versionResult = yield subProcess.execute(`${mavenCommand} --version`, [], {
                cwd: targetFilePath,
            });
            const parseResult = parse_mvn_1.parseTree(result, options.dev);
            const { javaVersion, mavenVersion } = parse_mvn_1.parseVersions(versionResult);
            let callGraph;
            let maybeCallGraphMetrics = {};
            if (options.reachableVulns) {
                debug(`getting call graph from path ${targetPath}`);
                try {
                    callGraph = yield javaCallGraphBuilder.getCallGraphMvn(path.dirname(targetPath));
                    maybeCallGraphMetrics = {
                        callGraphMetrics: javaCallGraphBuilder.runtimeMetrics(),
                    };
                    debug('got call graph successfully');
                }
                catch (err) {
                    debug('call graph error: ' + err);
                    throw new call_graph_error_1.CallGraphError(err.message, err);
                }
            }
            return {
                plugin: {
                    name: 'bundled:maven',
                    runtime: 'unknown',
                    meta: Object.assign({ versionBuildInfo: {
                            metaBuildVersion: {
                                mavenVersion,
                                javaVersion,
                            },
                        } }, maybeCallGraphMetrics),
                },
                package: parseResult.data,
                callGraph,
            };
        }
        catch (error) {
            error.message = buildErrorMessage(error, mvnArgs, mavenCommand);
            throw error;
        }
    });
}
exports.inspect = inspect;
function buildArgs(targetFile, mavenArgs) {
    // Requires Maven >= 2.2
    let args = ['dependency:tree', '-DoutputType=dot'];
    if (targetFile) {
        args.push('--file="' + targetFile + '"');
    }
    if (mavenArgs) {
        args = args.concat(mavenArgs);
    }
    return args;
}
exports.buildArgs = buildArgs;
function buildErrorMessage(error, mvnArgs, mavenCommand) {
    if (error instanceof call_graph_error_1.CallGraphError) {
        return error_format_1.formatCallGraphError(error);
    }
    return error_format_1.formatGenericPluginError(error, mavenCommand, mvnArgs);
}
//# sourceMappingURL=index.js.map