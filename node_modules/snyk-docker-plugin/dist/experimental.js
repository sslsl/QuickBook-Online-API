"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const os = require("os");
const path = require("path");
const image_inspector_1 = require("./analyzer/image-inspector");
const docker_1 = require("./docker");
const image_type_1 = require("./image-type");
const staticModule = require("./static");
const types_1 = require("./types");
function experimentalAnalysis(targetImage, dockerfileAnalysis, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // assume Distroless scanning
        const imageType = image_type_1.getImageType(targetImage);
        switch (imageType) {
            case types_1.ImageType.DockerArchive:
            case types_1.ImageType.OciArchive:
                return localArchive(targetImage, imageType, dockerfileAnalysis);
            case types_1.ImageType.Identifier:
                return distroless(targetImage, dockerfileAnalysis, options);
            default:
                throw new Error("Unhandled image type for image " + targetImage);
        }
    });
}
exports.experimentalAnalysis = experimentalAnalysis;
function localArchive(targetImage, imageType, dockerfileAnalysis) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const archivePath = image_type_1.getArchivePath(targetImage);
        if (!fs.existsSync(archivePath)) {
            throw new Error("The provided archive path does not exist on the filesystem");
        }
        if (!fs.lstatSync(archivePath).isFile()) {
            throw new Error("The provided archive path is not a file");
        }
        // The target image becomes the base of the path, e.g. "archive.tar" for "/var/tmp/archive.tar"
        const imageIdentifier = path.basename(archivePath);
        return yield getStaticAnalysisResult(imageIdentifier, archivePath, dockerfileAnalysis, imageType);
    });
}
// experimental flow expected to be merged with the static analysis when ready
function distroless(targetImage, dockerfileAnalysis, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (staticModule.isRequestingStaticAnalysis(options)) {
            options.staticAnalysisOptions.distroless = true;
            return staticModule.analyzeStatically(targetImage, dockerfileAnalysis, options);
        }
        yield image_inspector_1.pullIfNotLocal(targetImage);
        const archiveDir = path.join(os.tmpdir(), "snyk-image-archives");
        createTempDirIfMissing(archiveDir);
        // TODO terrible way to convert slashes to anything else
        // so we don't think it's a directory
        const archiveFileName = `${targetImage.replace(/\//g, "__")}.tar`;
        const archiveFullPath = path.join(archiveDir, archiveFileName);
        // assumption #1: the `docker` binary is available locally
        const docker = new docker_1.Docker(targetImage);
        yield docker.save(targetImage, archiveFullPath);
        try {
            return yield getStaticAnalysisResult(targetImage, archiveFullPath, dockerfileAnalysis, types_1.ImageType.DockerArchive);
        }
        finally {
            fs.unlinkSync(archiveFullPath);
        }
    });
}
exports.distroless = distroless;
function getStaticAnalysisResult(targetImage, archivePath, dockerfileAnalysis, imageType) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const scanningOptions = {
            staticAnalysisOptions: {
                imagePath: archivePath,
                imageType,
                distroless: true,
            },
        };
        return yield staticModule.analyzeStatically(targetImage, dockerfileAnalysis, scanningOptions);
    });
}
function createTempDirIfMissing(archiveDir) {
    try {
        fs.mkdirSync(archiveDir);
    }
    catch (err) {
        if (err.code !== "EEXIST") {
            throw err;
        }
    }
}
//# sourceMappingURL=experimental.js.map